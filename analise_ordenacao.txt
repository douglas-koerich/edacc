algoritmo bubble(v, n)
    entrada vetor v de n elements
    saida vetor ordenado de forma crescente

           (M)  (R)  (A)  (M+A) ----------------------> 1 + 4(n-1) + 2        = 4n - 1
    para r de 1 ate n - 1 passo 1 faca
               (M)  (R)    (M+A) ---------------------> [1 + 3(n-1) + 1](n-1) = 3n² - 4n + 1
        para i de n ate 2 passo -1 faca
               (D) (A) (D)   (R) (D)  (D) ------------> 6(n-1)(n-1)           = 6n² - 12n + 6
            se v[i - 1].chave > v[i].chave entao
                 (F)   (D)  (D)(A) -------------------> 4(n-1)(n-1)           = 4n² - 8n + 4   
                troca(v[i], v[i-1])
            fim-se
        fim-para
    fim-para
    ==========================================================================================
                                                                        T(n) = 13n² - 20n + 10
                                                                        Complexidade O(n²)

algoritmo merge(v, l, u)
    entrada segmento do vetor v da posicao l ate u
    saida segmento ordenado de forma crescente

         (R) ---------------------------------------------> 1
    se l >= u entao ; condicao terminal da recursividade
        retorna
    fim-se

    ; fase ativa da recursividade

      (M)  (A)  (A) --------------------------------------> 3
    m <- (l + u) / 2;
     T() -------------------------------------------------> T(n/2)
    merge(v, l, m);
     T()      (A) ----------------------------------------> T(n/2) + 1
    merge(v, m + 1, u);

      (M) (A) (A) ----------------------------------------> 3
    s <- u - l + 1;
     (M)     (M)  (A)    (M) -----------------------------> 4
    i <- l, j <- m + 1, k <- 0

               (R)      (R) ------------------------------> 2(n/2 + 1) ==> +1 para a condicao falsa dos testes
    enquanto i <= m e j <= u faca 
            (D)(D)   (R) (D)(D) --------------------------> 5(n/2)
        se v[i].chave < v[j].chave entao
             (D) (R) (D) ---------------------------------> 3(n/2)
            w[k] <- v[i]
             (M)  (A) ------------------------------------> 2(n/2)
            k <- k + 1
             (M)  (A) ------------------------------------> 2(n/2)
            i <- i + 1
        senao ; como nao acontece o "se" e o "senao" na mesma execucao, nao se conta um deles
            w[k] <- v[j]
            k <- k + 1
            j <- j + 1
        fim-se
    fim-para

               (R) ---------------------------------------> n/2 + 1
    enquanto i <= m faca
         (D) (R) (D) -------------------------------------> 3(n/2)    
        w[k] <- v[i]
         (M)  (A) ----------------------------------------> 2(n/2)
        k <- k + 1
         (M)  (A) ----------------------------------------> 2(n/2)
        i <- i + 1
    fim-para

    enquanto j <= u faca ; numa situacao de pior caso, nao havera execucao de um desses lacos que tratam
                         ; o que ficou de resto de cada segmento, assim nao se conta um deles
        w[k] <- v[j]
        k <- k + 1
        j <- j + 1
    fim-para
    
           (M)  (R)   (M+A) ------------------------------> 1 + (n+1) + 2n
    para i de 1 ate s passo 1 faca
         (D) (A) (A) (M) (D) -----------------------------> 5n
        v[l + i - 1] <- w[i] 
    fim-para
    ======================================================================================
                                                     T(n) = 2T(n/2) + 19n + 17, se n > 1
                                                          = 1, se n = 1

T(n) = 2T(n/2) + 19n + 17
     = 2[2T(n/4) + 19(n/2) + 17] + 19n + 17                    = 4T(n/4) + 2.19n + 17(2 + 1)
     = 2{2[2T(n/8) + 19(n/4) + 17] + 19(n/2) + 17)} + 19n + 17 = 8T(n/8) + 3.19n + 17(4 + 2 + 1)
     = ...
     = 2^i.T(n/2^i) + i.19n + 17(1 + 2 + 4 + ... + 2^(i-1))
     = 2^i.T(n/2^i) + i.19n + 17.__1(2^i - 1)__
                                    (2 - 1)
T(n) = 2^i.T(n/2^i) + i.19n + 17(2^i - 1)  <<<==== FORMULA GERAL DA FUNCAO DE COMPLEXIDADE

Fazendo i = lg(n), i.e. i igual ao logaritmo de n na base 2, tem-se

T(n) = 2^(lg(n)).T(n/2^(lg(n))) + lg(n).19n + 17(2^(lg(n)) - 1)
     = n.T(1) + 19n.lg(n) + 17(n-1)
     = n.1 + 19n.lg(n) + 17n - 1

T(n) = 19n.lg(n) + 18n - 1
Complexidade: O(n.lg(n))
